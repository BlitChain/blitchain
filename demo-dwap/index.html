<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Blit-Dwap Template</title>

  </head>
  <body>
    <!-- External Libraries -->
    <script type="module">
      import blitjs from "https://cdn.jsdelivr.net/npm/@blitchain/blitjs@1.0.2/+esm";


      /*
      // NOTE : this does not work in the browser directly, you need to use a bundler like webpack
      import { Registry, DirectSecp256k1HdWallet } from "https://cdn.jsdelivr.net/npm/@cosmjs/proto-signing@0.31.3/+esm";

      // Client setup for Mnemonic
      // Uncaught TypeError: Cannot read properties of null (reading 'sha256')

      const makeMnemonicClient = async (rpcEndpoint,mnemonic) => {
        if (!mnemonic) {
          mnemonic = await DirectSecp256k1HdWallet.generate(24);
        }
        const signer = await DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {
          prefix: "blit",
        });
        const registry = setupRegistry();
        const client = await SigningStargateClient.connectWithSigner(
          rpcEndpoint,
          signer,
          { registry }
        );
        return client;
      };
      */


      // Client setup for Keplr
      const makeKeplrClient = (rpcEndpoint, restEndpoint, chainId) => {
        var addressPrefix = "blit";
        return new Promise(async (resolve, reject) => {
          if (!window.keplr) {
            reject(new Error("Please install keplr extension"));
          } else {
            try {
              await window.keplr.experimentalSuggestChain({
                features: [],
                chainId: chainId,
                chainName: "Blit Development Chain",
                rpc: rpcEndpoint,
                rest: restEndpoint,
                Currency: {
                  coinDenom: "blit",
                  coinMinimalDenom: "blit",
                  coinDecimals: 0,
                },
                bip44: {
                  coinType: 118,
                },
                bech32Config: {
                  bech32PrefixAccAddr: addressPrefix,
                  bech32PrefixAccPub: addressPrefix + "pub",
                  bech32PrefixValAddr: addressPrefix + "valoper",
                  bech32PrefixValPub: addressPrefix + "valoperpub",
                  bech32PrefixConsAddr: addressPrefix + "valcons",
                  bech32PrefixConsPub: addressPrefix + "valconspub",
                },
                currencies: [
                  {
                    coinDenom: "blit",
                    coinMinimalDenom: "blit",
                    coinDecimals: 0,
                  },
                ],
                feeCurrencies: [
                  {
                    coinDenom: "blit",
                    coinMinimalDenom: "blit",
                    coinDecimals: 0,
                    gasPriceStep: { low: 0.0, average: 0.000001, high: 1 },
                  },
                ],
              });
              await window.keplr.enable(chainId);
              let offlineSigner = await window.getOfflineSigner(chainId);
              let client = await blitjs.getSigningBlitClient({
                rpcEndpoint,
                signer: offlineSigner
              });
              resolve(client);
            } catch (error) {
              reject(error);
            }
          }
        });
      };

      // Helper function to run a script function and return the result from the run or error
      const run = async (
        client,
        caller_address,
        script_address,
        function_name,
        kwargs
      ) => {
        let msg = blitjs.blit.script.MessageComposer.withTypeUrl.run({
          caller_address,
          script_address,
          function_name,
          kwargs: JSON.stringify(kwargs),
        });
        let resp = await sendMsg(client, caller_address, msg);
        if (resp.code !== 0) {
          // So we split into lines and get the last line which is the error
          let lastLine = resp.rawLog.split("\n").slice(-1)[0];
          // strip ": Exception in Script" only from lastLine (technically this will remove it anywhere in the result, but that's fine)
          let result = lastLine.replace(": Exception in Script", "");
          return JSON.parse(result);
        }
        let msgResponse = resp.msgResponses[0];
        // Parse the response
        return JSON.parse(
          blitjs.blit.script.MsgRunResponse.fromProtoMsg(msgResponse).response
        );
      };

      // Helper function to sign and broadcast
      const sendMsg = async (client, address, message) => {
        let fee = {
          amount: [{ amount: "0", denom: "blit" }],
          gas: "100000",
        };
        let response = await client.signAndBroadcast(address, [message], fee);
        return response;
      };

      // Query client setup
      const makeQueryClient = async (restEndpoint) => {
        return await blitjs.blit.ClientFactory.createLCDClient({
          restEndpoint,
        });
      };

      window.blitjs = blitjs;
      window.makeKeplrClient = makeKeplrClient;
      window.makeQueryClient = makeQueryClient;
      window.run = run;
      window.sendMsg = sendMsg;
    </script>
    <pre>
<samp>
/*
// Example usage of Blitjs

Open the console and run the following commands.
Also look at the source code for this page to see how it works.

// Keplr example
msgClient = await makeKeplrClient(
  "http://testnet.blitchain.net:26657",
  "http://testnet.blitchain.net:1317",
  "blit-dev"
);


// Query client example
queryClient = await makeQueryClient("http://testnet.blitchain.net:1317");

// Get your address
address = (await msgClient.signer.getAccounts())[0].address;

// Send a message to update a script
// Important: watch the indentaion
let code = `def greet(name): // this is not indented
    print(f"Hello {name}!")    // these are indented
    return {"name": name}`
await sendMsg(msgClient, address, blitjs.blit.script.MessageComposer.fromPartial.updateScript({address, code: code}))

// Run the "greet" function from the script you just updated
// assuming you have a script at your address with the function above
runResp = await run(msgClient, address, address, "greet", {
  name: "bob",
});

// Query example of the previous function
JSON.parse(
  (await queryClient.blit.script.eval({ script_address: address, called_address: address, function_name: "greet", kwargs: JSON.stringify({name: "Bob"}) }))
    .response
);
OUTPUT: 
{
    "exception": null,
    "gas_limit": 10000000,
    "nodes_called": 15,
    "result": {
        "name": "Bob"
    },
    "script_gas_consumed": 1568,
    "stdout": "Hello Bob!\n"
}

// Send a message to create then update storage
await sendMsg(
  msgClient,
  address,
  blitjs.blit.storage.MessageComposer.fromPartial.createStorage({
    address,
    index: "foo123",
    data: "some data",
  })
);
await sendMsg(
  msgClient,
  address,
  blitjs.blit.storage.MessageComposer.fromPartial.updateStorage({
    address,
    index: "foo123",
    data: "some NEW data",
  })
);

// Query all storage for an address example
await queryClient.blit.storage.storageAll({ filter_address: address });

// Query a specific storage index for an address example
await queryClient.blit.storage.storage({ address, index: "foo123" });

// Query a script for it's code and version
await queryClient.blit.script.script({ address });

// Send a message example to update a script
await sendMsg(
  msgClient,
  address,
  blitjs.blit.script.MessageComposer.fromPartial.updateScript({
    address,
    code: newCode,
  })
);

// Query all balances for an address example
await queryClient.cosmos.bank.v1beta1.allBalances({ address, pagination: {limit:"1", offset:0, countTotal:true}})
OUTPUT:
{ "balances": [ { "denom": "blit", "amount": "8419444" } ], "pagination": { "next_key": "dG9rZW4=", "total": "2" } }

await queryClient.cosmos.bank.v1beta1.allBalances({ address, pagination: {limit:"1", offset:1, countTotal:true}})
OUTPUT:
{ "balances": [ { "denom": "token", "amount": "20000" } ], "pagination": { "next_key": null, "total": "2" } } 
*/
</samp>
    </pre>
  </body>
</html>
